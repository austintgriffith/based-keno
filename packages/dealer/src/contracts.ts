import { readFileSync, existsSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Path to nextjs package (where deployedContracts.ts lives)
const NEXTJS_PATH = join(__dirname, "..", "..", "nextjs");

interface ContractInfo {
  address: `0x${string}`;
  abi: readonly object[];
}

interface ChainContracts {
  [contractName: string]: ContractInfo;
}

interface DeployedContracts {
  [chainId: number]: ChainContracts;
}

interface LoadedContract {
  address: `0x${string}`;
  abi: readonly object[];
}

// Cache for loaded contracts
let contractsCache: DeployedContracts | null = null;

/**
 * Load and parse deployedContracts.ts from nextjs package
 * This file is auto-generated by Scaffold-ETH and contains all ABIs and addresses
 */
function loadDeployedContracts(): DeployedContracts {
  if (contractsCache) {
    return contractsCache;
  }

  const contractsPath = join(NEXTJS_PATH, "contracts", "deployedContracts.ts");

  if (!existsSync(contractsPath)) {
    throw new Error(
      `deployedContracts.ts not found. Expected file at: ${contractsPath}`
    );
  }

  const content = readFileSync(contractsPath, "utf8");

  // Extract the contracts object from the TypeScript file
  // The file exports: const deployedContracts = { ... } as const;
  // We need to parse this as JavaScript

  // Remove TypeScript-specific imports and type assertions
  let jsContent = content
    // Remove import statements
    .replace(/import\s+.*?from\s+['"][^'"]+['"];?\s*/g, "")
    // Remove "as const" assertions
    .replace(/\s+as\s+const\s*;?/g, ";")
    // Remove type annotations like ": GenericContractsDeclaration"
    .replace(/:\s*GenericContractsDeclaration/g, "")
    // Remove "satisfies" expressions
    .replace(/\s+satisfies\s+\w+/g, "");

  // Extract the object from "const deployedContracts = { ... }"
  const match = jsContent.match(
    /const\s+deployedContracts\s*=\s*(\{[\s\S]*\});?\s*(?:export\s+default|$)/
  );

  if (!match) {
    throw new Error(
      "Could not parse deployedContracts.ts - format not recognized"
    );
  }

  // Use Function constructor to safely evaluate the object literal
  // This is safer than eval() and works for object literals
  try {
    const evalFn = new Function(`return ${match[1]}`);
    contractsCache = evalFn() as DeployedContracts;
    return contractsCache;
  } catch (error) {
    throw new Error(
      `Failed to parse deployedContracts.ts: ${
        error instanceof Error ? error.message : error
      }`
    );
  }
}

/**
 * Load a deployed contract's address and ABI
 */
export function loadContract(
  chainId: number,
  contractName: string
): LoadedContract {
  const contracts = loadDeployedContracts();

  const chainContracts = contracts[chainId];
  if (!chainContracts) {
    throw new Error(
      `No deployments found for chain ${chainId}. Available chains: ${Object.keys(
        contracts
      ).join(", ")}`
    );
  }

  const contract = chainContracts[contractName];
  if (!contract) {
    throw new Error(
      `Contract ${contractName} not found on chain ${chainId}. Available contracts: ${Object.keys(
        chainContracts
      ).join(", ")}`
    );
  }

  return {
    address: contract.address,
    abi: contract.abi,
  };
}

/**
 * Load all deployed contracts for a chain
 */
export function loadAllContracts(
  chainId: number
): Record<string, LoadedContract> {
  const contracts = loadDeployedContracts();

  const chainContracts = contracts[chainId];
  if (!chainContracts) {
    throw new Error(
      `No deployments found for chain ${chainId}. Available chains: ${Object.keys(
        contracts
      ).join(", ")}`
    );
  }

  const result: Record<string, LoadedContract> = {};

  for (const [name, contract] of Object.entries(chainContracts)) {
    result[name] = {
      address: contract.address,
      abi: contract.abi,
    };
  }

  return result;
}

/**
 * Check if deployments exist for a chain
 */
export function hasDeployments(chainId: number): boolean {
  try {
    const contracts = loadDeployedContracts();
    return chainId in contracts && Object.keys(contracts[chainId]).length > 0;
  } catch {
    return false;
  }
}
